/**
 * Введение в Lambda-выражения
 * Lambda-выражения – это анонимные функции (может и не 100% верное определение для Java, но зато привносит некоторую ясность).
 * Проще говоря, это метод без объявления, т.е. без модификаторов доступа, возвращающие значение и имя.
 *
 * Короче говоря, они позволяют написать метод и сразу же использовать его. Особенно полезно в с
 * лучае однократного вызова метода, т.к. сокращает время на объявление и написание метода без необходимости создавать класс.
 *
 * Lambda-выражения в Java обычно имеют следующий синтаксис (аргументы) -> (тело). Например:
 *
 * (арг1, арг2...) -> { тело }
 *
 * (тип1 арг1, тип2 арг2...) -> { тело }
 *
 *
 * Далее идет несколько примеров настоящих Lambda-выражений:
 *
 * (int a, int b) -> {  return a + b; }
 *
 * () -> System.out.println("Hello World");
 *
 * (String s) -> { System.out.println(s); }
 *
 * () -> 42
 *
 * () -> { return 3.1415 };
 *
 *
 * Структура Lambda-выражений
 * Давайте изучим структуру lambda-выражений:
 * Lambda-выражения могут иметь от 0 и более входных параметров.
 * Тип параметров можно указывать явно либо может быть получен из контекста. Например (int a) можно записать и так (a)
 * Параметры заключаются в круглые скобки и разделяются запятыми. Например (a, b) или (int a, int b) или (String a, int b, float c)
 * Если параметров нет, то нужно использовать пустые круглые скобки. Например () -> 42
 * Когда параметр один, если тип не указывается явно, скобки можно опустить. Пример: a -> return a*a
 * Тело Lambda-выражения может содержать от 0 и более выражений.
 * Если тело состоит из одного оператора, его можно не заключать в фигурные скобки, а
 * возвращаемое значение можно указывать без ключевого слова return.
 * В противном случае фигурные скобки обязательны (блок кода), а в конце надо указывать
 * возвращаемое значение с использованием ключевого слова return (в противном случае типом возвращаемого значения будет void).
 *
 *
 *
 *
 *
 * Что такое функциональный интерфейс
 * В Java, маркерные интерфейсы (Marker interface) – это интерфейсы без объявления методов и полей.
 * Другими словами маркерные интерфейсы – это пустые интерфейсы.
 * Точно также, функциональные интерфейсы (Functional Interface) – это интерфейсы только с одним абстрактным методом, объявленным в нем.
 *
 * java.lang.Runnable – это пример функционального интерфейса. В нем объявлен только один метод void run().
 * Также есть интерфейс ActionListener – тоже функциональный. Раньше нам приходилось использовать
 * анонимные классы для создания объектов, реализующих функциональный интерфейс. С Lambda-выражениями, все стало проще.
 *
 * Каждое lambda-выражение может быть неявно привязано к какому-нибудь функциональному интерфейсу.
 * Например, можно создать ссылку на Runnable интерфейс, как показано в следующем примере:
 *
 * Runnable r = () -> System.out.println("hello world");
 *
 * Подобное преобразование всегда осуществляется неявно, когда мы не указываем функциональный интерфейс:
 *
 * new Thread(
 *     () -> System.out.println("hello world")
 * ).start();
 *
 * В примере выше, компилятор автоматически создает lambda-выражение как реализацию
 * Runnable интерфейса из конструктора класса Thread: public Thread(Runnable r) { }.
 *
 * Приведу несколько примеров lambda-выражений и соответствующих функциональных интерфейсов:
 *
 * Consumer<Integer> c = (int x) -> { System.out.println(x) };
 *
 * BiConsumer<Integer, String> b = (Integer x, String y) -> System.out.println(x + " : " + y);
 *
 * Predicate<String> p = (String s) -> { s == null };
 *
 * Аннотация @FunctionalInterface, добавленная в Java 8 согласно Java Language Specification,
 * проверяет является ли объявляемый интерфейс функциональным. Кроме того,
 * в Java 8 включен ряд готовых функциональных интерфейсов для использования с
 * Lambda-выражениями. @FunctionalInterface выдаст ошибку компиляции,
 * если объявляемый интерфейс не будет функциональным.
 *
 *
 */

//// Далее приводится пример определения функционального интерфейса:/// Смотри для этого проэкта создал его отдельно

/**
Как следует из определения, функциональный интерфейс может иметь только один абстрактный метод.
Если попытаться добавить еще один абстрактный метод, то вылезет ошибка компиляции. */









public class LambdaStatya {

    public static void execute(WorkerInterface worker) {
        worker.doSomeWork();
    }

    public static void main(String [] args) {

        // вызов метода doSomeWork через анонимный класс
        // (классический способ)
        execute(new WorkerInterface() {
            @Override
            public void doSomeWork() {
                System.out.println("Worker вызван через анонимный класс");
            }
        });

        // вызов метода doSomeWork через Lambda-выражения
        // (нововведение Java 8)
        execute( () -> System.out.println("Worker вызван через Lambda") );
    }

    /**
     *
     * Вывод результата (можно запустить чтобы проверить):
     *
     * Worker вызван через анонимный класс
     * Worker вызван через Lambda

     Здесь мы определили свой собственный функциональный интерфейс
     и воспользовались lambda-выражением.
     Метод execute() способен принимать lambda-выражения в качестве аргумента.

     */


    /**
    Примеры Lambda-выражений
    Лучший способ вникнуть в Lambda-выражения – это рассмотреть несколько примеров:

    Поток Thread можно проинициализировать двумя способами:
     */




}
